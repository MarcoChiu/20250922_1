<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>題目二：書籍蒐尋器</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
    <link href="../css/style.css" rel="stylesheet">
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        main {
            background: teal;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        ul {
            padding: 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <h2>題目二：書籍蒐尋器</h2>
        <p>請達成以下功能：</p>
        <ul>
            <li>(加載網頁時) > 將預備好的資料注入在網頁上，呈現：「書名 - 介紹」的清單。</li>
            <li>(用戶輸入時) > 從預備好的資料中搜尋，並過濾所有清單。</li>
        </ul>
        <p>✨keywords：element.textContent, element.innerHTML, array.filter()</p>
        <main>
            <h3>書本查詢器</h3>
            <form autocomplete="off">
                <div>
                    <input type="text" name="searchBook" placeholder="搜尋書籍" class="input" required>
                    <ul class="suggestion">
                    </ul>
                </div>
            </form>

            <ul class="result">
            </ul>
        </main>
        <script>
            //搜尋的步驟
            //1.在一開始就把資料庫的內容呈現在畫面上
            //2.當搜尋時，能第一時間監聽搜尋的內容

            //tip 通常不太會這麼做，除非資料已經在本地端，否則在搜尋資料時是會向伺服器發送請求調用資料庫資料，但若以目前的方式會不斷發送請求造成流量的損耗(要花的錢更多)，但若已經將所有資料取得回來就不會有這個問題。

            //3.有符合的就將按鈕渲染到畫面上
            //4.點擊能直接連結到該項資料呈現在下方

            //這邊先建立一段資料
            let bookData = [
                {
                    name: "Harry Potter",
                    description: "content 01"
                },
                {
                    name: "Old Man And Sea",
                    description: "content 02"
                },
                {
                    name: "Hello World",
                    description: "content 03"
                }
            ];

            const input = document.querySelector(".input");
            const suggestion = document.querySelector(".suggestion");
            const result = document.querySelector(".result");

            //這裡監聽搜尋的 input ，當有輸入的動作時便會觸發動作
            input.addEventListener("input", (e) => {

                //這裡處理輸入的資料，先提取出資料後，將內容一同小寫再去除前後的空格
                //因為搜尋方面大小寫會有區分，若大小寫不一致會出現搜尋的誤差
                const inputWord = e.target.value.toLowerCase().trim();

                //將資料庫的資料使用 filter 搜尋，接著使用 .includes() 的方式搜尋上面鍵入的內容，之後會存在 filteredBooks 內。
                const filteredBooks = bookData.filter((i) => {
                    return i.name.toLowerCase().includes(inputWord);
                });
                renderBtn(filteredBooks);
            });

            //渲染按鈕
            function renderBtn(data) {
                let renderBtnList = "";

                //接收上面的資料後，使用 forEach 跑迴圈建立 HTML
                data.forEach((i) => {
                    let word = `<li><button class="btn" type="button">${i.name}</button></li>`;
                    renderBtnList += word;
                });
                suggestion.innerHTML = renderBtnList;
            }

            //當 suggestion 的資料被點擊時
            suggestion.addEventListener("click", (e) => {

                //會去搜尋內容的 class 有沒有 btn
                if (e.target.classList.contains("btn")) {

                    //提取 button 的文字
                    const buttonContent = e.target.textContent;

                    //將資料庫文字與提取的 button 比對
                    const filteredBooks = bookData.filter((i) => {
                        return i.name.includes(buttonContent);
                    });

                    //最後搜尋到的資料導向選染結果的函式
                    renderSearch(filteredBooks)
                }
            });

            //tip 可能會有一個疑問，為什麼不建立 const btn = document.querySelector(".btn"); ，這是因為元素產生的過程，若要在一開始就建立 btn ，但這個時候畫面上不會有 btn 的資料所以無法建立，所以這邊使用這種方式取得該資料(另外也有不同的方式可以操作，像是在產生資料後便建立也可取得該資料，但後續的相關監聽動作需要連動的改變)

            //當點擊時，所有的資料都會呈現。
            input.addEventListener('click', () => {

                //這邊就導入 renderSearch() ，因為參數沒有任何資料，所以會走 !data 這個判斷式。
                renderSearch();
            });

            //渲染結果

            function renderSearch(data) {
                let renderSearchList = '';

                //若沒有資料時，讓所有的資料都呈現在畫面上，有資料時就使用變數的資料
                if (!data) {
                    data = bookData;
                };
                data.forEach((i) => {
                    let word =
                        `<li class="text-white">${i.name} - ${i.description}</li>`;
                    renderSearchList += word;
                });
                result.innerHTML = renderSearchList;
            }

            //因為作業呈現，最初式會有所有資料的，所以這邊會先執行一次函式渲染結果
            renderSearch();
        </script>

        <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"
            integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r"
            crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.min.js"
            integrity="sha384-G/EV+4j2dNv+tEPo3++6LCgdCROaejBqfUeNjuKAiuXbjrxilcCdDz6ZAVfHWe1Y"
            crossorigin="anonymous"></script>
        <script src='https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js'></script>
        <script src="../js/nav.js"></script>
</body>

</html>